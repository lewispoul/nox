#!/bin/bash

# noxctl - Interface CLI unifiée pour Nox API
# Version: 1.0
# Auteur: COPILOT_PLAN.md - Étape 7

set -euo pipefail

# Variables globales
SCRIPT_NAME="noxctl"
VERSION="1.0"
CONFIG_FILE="/etc/default/nox-api"
API_BASE="http://127.0.0.1:8080"

# Couleurs pour l'affichage
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Fonctions utilitaires
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[OK]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Lecture du token depuis /etc/default/nox-api
get_auth_token() {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        log_error "Fichier de configuration non trouvé: $CONFIG_FILE"
        exit 1
    fi
    
    # Lecture du token depuis le fichier (avec sudo si nécessaire)
    local token
    token=$(sudo grep -E '^NOX_API_TOKEN=' "$CONFIG_FILE" 2>/dev/null | cut -d= -f2- | tr -d '"' || true)
    
    if [[ -z "$token" ]]; then
        log_error "Token NOX_API_TOKEN non trouvé dans $CONFIG_FILE"
        log_error "Vérifiez que le fichier existe et contient NOX_API_TOKEN=..."
        exit 1
    fi
    
    echo "$token"
}

# Fonction générique pour appeler l'API
api_call() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local content_type="${4:-application/json}"
    
    local token
    token=$(get_auth_token)
    
    local curl_args=(
        -s
        -w "\nHTTP_CODE:%{http_code}"
        -H "Authorization: Bearer $token"
        -X "$method"
        "$API_BASE$endpoint"
    )
    
    if [[ -n "$data" ]]; then
        curl_args+=(-H "Content-Type: $content_type" -d "$data")
    fi
    
    curl "${curl_args[@]}"
}

# Commande: health - Vérification de l'état de l'API
cmd_health() {
    log_info "Vérification de l'état de l'API Nox..."
    
    # Vérifier le token d'abord
    local token
    token=$(get_auth_token) || return 1
    
    local response
    response=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
        -H "Authorization: Bearer $token" \
        -X GET \
        "$API_BASE/health" 2>&1) || {
        log_error "Impossible de contacter l'API sur $API_BASE"
        return 1
    }
    
    local http_code
    http_code=$(echo "$response" | tail -n1 | grep "HTTP_CODE:" | cut -d: -f2)
    local body
    body=$(echo "$response" | sed '$d')  # Remove last line with HTTP_CODE
    
    if [[ "$http_code" == "200" ]] && [[ "$body" == '{"status":"ok"}' ]]; then
        log_success "API Nox accessible et opérationnelle"
        echo "Status: ok"
        return 0
    else
        log_error "API ne répond pas correctement (HTTP $http_code)"
        echo "Response: $body"
        return 1
    fi
}

# Commande: put - Upload d'un fichier local vers le sandbox
cmd_put() {
    if [[ $# -lt 2 ]]; then
        log_error "Usage: $SCRIPT_NAME put <fichier_local> <chemin_relatif_sandbox>"
        echo "Exemple: $SCRIPT_NAME put ./script.py scripts/script.py"
        return 1
    fi
    
    local local_file="$1"
    local remote_path="$2"
    
    if [[ ! -f "$local_file" ]]; then
        log_error "Fichier local non trouvé: $local_file"
        return 1
    fi
    
    log_info "Upload de '$local_file' vers sandbox:'$remote_path'..."
    
    # Vérifier le token d'abord
    local token
    token=$(get_auth_token) || return 1
    
    local response
    response=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
        -H "Authorization: Bearer $token" \
        -F "f=@$local_file" \
        -X POST \
        "$API_BASE/put?path=$remote_path" 2>&1) || {
        log_error "Échec de l'upload"
        return 1
    }
    
    local http_code
    http_code=$(echo "$response" | tail -n1 | grep "HTTP_CODE:" | cut -d: -f2)
    local body
    body=$(echo "$response" | sed '$d')
    
    if [[ "$http_code" == "200" ]]; then
        log_success "Fichier uploadé avec succès"
        echo "$body" | jq . 2>/dev/null || echo "$body"
        return 0
    else
        log_error "Échec de l'upload (HTTP $http_code)"
        echo "$body"
        return 1
    fi
}

# Commande: runpy - Exécution de code Python
cmd_runpy() {
    if [[ $# -lt 1 ]]; then
        log_error "Usage: $SCRIPT_NAME runpy <code_python|fichier.py>"
        echo "Exemples:"
        echo "  $SCRIPT_NAME runpy 'print(\"Hello World\")'"
        echo "  $SCRIPT_NAME runpy script.py"
        return 1
    fi
    
    local code_or_file="$1"
    local python_code
    
    # Déterminer si c'est un fichier ou du code direct
    if [[ -f "$code_or_file" ]]; then
        log_info "Exécution du fichier Python: $code_or_file"
        python_code=$(cat "$code_or_file")
    else
        log_info "Exécution du code Python direct"
        python_code="$code_or_file"
    fi
    
    # Vérifier le token d'abord
    local token
    token=$(get_auth_token) || return 1
    
    # Préparation des données JSON
    local json_data
    json_data=$(jq -n --arg code "$python_code" '{code: $code}')
    
    local response
    response=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
        -H "Authorization: Bearer $token" \
        -H "Content-Type: application/json" \
        -d "$json_data" \
        -X POST \
        "$API_BASE/run_py" 2>&1) || {
        log_error "Échec de l'exécution Python"
        return 1
    }
    
    local http_code
    http_code=$(echo "$response" | tail -n1 | grep "HTTP_CODE:" | cut -d: -f2)
    local body
    body=$(echo "$response" | sed '$d')
    
    echo "=== RÉSULTAT PYTHON ==="
    if [[ "$http_code" == "200" ]]; then
        local stdout stderr returncode
        stdout=$(echo "$body" | jq -r '.stdout' 2>/dev/null || echo "")
        stderr=$(echo "$body" | jq -r '.stderr' 2>/dev/null || echo "")
        returncode=$(echo "$body" | jq -r '.returncode' 2>/dev/null || echo "")
        
        if [[ -n "$stdout" ]]; then
            echo "$stdout"
        fi
        if [[ -n "$stderr" ]]; then
            echo "STDERR: $stderr" >&2
        fi
        
        if [[ "$returncode" == "0" ]]; then
            return 0
        else
            log_error "Code de retour Python: $returncode"
            return 1
        fi
    else
        log_error "Échec de l'exécution (HTTP $http_code)"
        echo "$body"
        return 1
    fi
}

# Commande: runsh - Exécution de commande shell
cmd_runsh() {
    if [[ $# -lt 1 ]]; then
        log_error "Usage: $SCRIPT_NAME runsh <commande_shell>"
        echo "Exemple: $SCRIPT_NAME runsh 'ls -la'"
        return 1
    fi
    
    local shell_cmd="$*"
    
    log_info "Exécution de la commande shell: $shell_cmd"
    
    # Vérifier le token d'abord
    local token
    token=$(get_auth_token) || return 1
    
    # Préparation des données JSON
    local json_data
    json_data=$(jq -n --arg cmd "$shell_cmd" '{cmd: $cmd}')
    
    local response
    response=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
        -H "Authorization: Bearer $token" \
        -H "Content-Type: application/json" \
        -d "$json_data" \
        -X POST \
        "$API_BASE/run_sh" 2>&1) || {
        log_error "Échec de l'exécution shell"
        return 1
    }
    
    local http_code
    http_code=$(echo "$response" | tail -n1 | grep "HTTP_CODE:" | cut -d: -f2)
    local body
    body=$(echo "$response" | sed '$d')
    
    echo "=== RÉSULTAT SHELL ==="
    if [[ "$http_code" == "200" ]]; then
        local stdout stderr returncode
        stdout=$(echo "$body" | jq -r '.stdout' 2>/dev/null || echo "")
        stderr=$(echo "$body" | jq -r '.stderr' 2>/dev/null || echo "")
        returncode=$(echo "$body" | jq -r '.returncode' 2>/dev/null || echo "")
        
        if [[ -n "$stdout" ]]; then
            echo "$stdout"
        fi
        if [[ -n "$stderr" ]]; then
            echo "STDERR: $stderr" >&2
        fi
        
        if [[ "$returncode" == "0" ]]; then
            return 0
        else
            log_error "Code de retour shell: $returncode"
            return 1
        fi
    else
        log_error "Échec de l'exécution (HTTP $http_code)"
        echo "$body"
        return 1
    fi
}

# Affichage de l'aide
show_help() {
    cat << EOF
$SCRIPT_NAME v$VERSION - Interface CLI unifiée pour Nox API

USAGE:
    $SCRIPT_NAME <commande> [arguments...]

COMMANDES:
    health                              Vérifier l'état de l'API
    put <fichier_local> <chemin_remote> Uploader un fichier vers le sandbox
    runpy <code|fichier.py>            Exécuter du code Python
    runsh <commande>                   Exécuter une commande shell
    version                            Afficher la version
    help                               Afficher cette aide

EXEMPLES:
    # Vérifier que l'API fonctionne
    $SCRIPT_NAME health
    
    # Uploader un script
    $SCRIPT_NAME put ./mon_script.py scripts/mon_script.py
    
    # Exécuter du code Python direct
    $SCRIPT_NAME runpy 'import os; print(os.getcwd())'
    
    # Exécuter un fichier Python
    $SCRIPT_NAME runpy ./test.py
    
    # Exécuter une commande shell
    $SCRIPT_NAME runsh 'ls -la /home/nox/nox/sandbox'
    
    # Chaîner des opérations
    $SCRIPT_NAME put script.py scripts/script.py && $SCRIPT_NAME runpy scripts/script.py

CONFIGURATION:
    Token d'authentification lu depuis: $CONFIG_FILE
    API endpoint: $API_BASE

NOTES:
    - Tous les chemins pour 'put' sont relatifs au sandbox (/home/nox/nox/sandbox)
    - Les exécutions Python et shell s'effectuent dans le sandbox sécurisé
    - Un token Bearer valide est requis dans $CONFIG_FILE
    
EOF
}

# Point d'entrée principal
main() {
    case "${1:-help}" in
        health)
            cmd_health
            ;;
        put)
            shift
            cmd_put "$@"
            ;;
        runpy)
            shift
            cmd_runpy "$@"
            ;;
        runsh)
            shift
            cmd_runsh "$@"
            ;;
        version)
            echo "$SCRIPT_NAME version $VERSION"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            log_error "Commande inconnue: ${1:-}"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Vérifications préalables
check_dependencies() {
    local missing_deps=()
    
    if ! command -v curl >/dev/null 2>&1; then
        missing_deps+=("curl")
    fi
    
    if ! command -v jq >/dev/null 2>&1; then
        missing_deps+=("jq")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        log_error "Dépendances manquantes: ${missing_deps[*]}"
        echo "Installation requise: sudo apt update && sudo apt install -y ${missing_deps[*]}"
        exit 1
    fi
}

# Exécution si script appelé directement
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    check_dependencies
    main "$@"
fi
